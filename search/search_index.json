{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to artml - Adaptive Real Time Machine Learning World of Real time Learning artml is a high-level Machine Learning API, written in Python and capable of running and building all linear models. It was developed with a focus on enabling continous and real time learning. Current hype is about Deep learning, But the future is deep with real learning. Welcome to the world of Real Learning! Use artml if you need a Machine Learning library that: Allows for easy and fast prototyping of real time learning linear models (through user friendliness, modularity, and atomic level builtin model designs). Current version supports all the linear models for classification & Regression tasks. Read the documentation at artml.io. artml is compatible with: Python 3 Installation Easily install artml from the GitHub source: First, clone artml using git: git clone https://github.com/AdaptiveMachineLearning/artml.git Then, import artml library into your python notebooks or files Contact: Have any questions? Shoot me an email and I shall get back to you asap! Also, we are looking to expand the artml team, contact me if you are interested. Happy Learning! Details Sundeep Pothula MEng \u2013 Industrial Engineering University of Toronto Email : sundeep.pothula@mail.utoronto.ca","title":"Home"},{"location":"#welcome-to-artml-adaptive-real-time-machine-learning","text":"","title":"Welcome to artml - Adaptive Real Time Machine Learning"},{"location":"#world-of-real-time-learning","text":"artml is a high-level Machine Learning API, written in Python and capable of running and building all linear models. It was developed with a focus on enabling continous and real time learning. Current hype is about Deep learning, But the future is deep with real learning. Welcome to the world of Real Learning! Use artml if you need a Machine Learning library that: Allows for easy and fast prototyping of real time learning linear models (through user friendliness, modularity, and atomic level builtin model designs). Current version supports all the linear models for classification & Regression tasks. Read the documentation at artml.io. artml is compatible with: Python 3","title":"World of Real time Learning"},{"location":"#installation","text":"Easily install artml from the GitHub source: First, clone artml using git: git clone https://github.com/AdaptiveMachineLearning/artml.git Then, import artml library into your python notebooks or files","title":"Installation"},{"location":"#contact","text":"Have any questions? Shoot me an email and I shall get back to you asap! Also, we are looking to expand the artml team, contact me if you are interested. Happy Learning! Details Sundeep Pothula MEng \u2013 Industrial Engineering University of Toronto Email : sundeep.pothula@mail.utoronto.ca","title":"Contact:"},{"location":"Dataexploration/","text":"Real Time Data exploration Real time Data Exploration can be categorized into two types: Real time Univariate Data Exploration Real time Bivariate Data Exploration Univariate exploration Use univariate function to get the summarized univariate statistics for the data. Only argument needed for this function is the BET table for generating the summarized results. It returns a dataframe with all the univariate stats. #Importing artml explore module for calculating univariate from artml.explore import stats stats.univariate(BET) Created univarate statistics table looks like the one below. As the BET gets updated with new data, table also updates in real time to display the stats Stats feature 1 feature 2 feature 3 feature 4 feature 5 Count ---------- --------- --------- --------- --------- Mean ---------- --------- --------- --------- --------- Variance ---------- --------- --------- --------- --------- Standard_deviation ---------- --------- --------- --------- --------- coeff_of_variation ---------- --------- --------- --------- --------- skewness ---------- --------- --------- --------- --------- Kurtosis ---------- --------- --------- --------- --------- Bivariate exploration For getting bivariate stats for the data use covariance or correlation functions. These functions explores the concept of relationship between two attributes, whether there is an association and the strength of this association. ## Import artml explore module for calculating bivariate from artml.explore import stats stats.covariance(BET) stats.correlation(BET) Also, for comparing whether there are differences between two attributes and the significance of these differences, use Ztest or Ttest functions. stats.Ztest(BET, 'feature1name','feature2name') stats.Ttest(BET, 'feature1name','feature2name') Similarly, we can perform Ftest, ANOVA & Chi2 test using the syntaxes in the artml library.","title":"Real Time Data Exploration"},{"location":"Dataexploration/#real-time-data-exploration","text":"Real time Data Exploration can be categorized into two types: Real time Univariate Data Exploration Real time Bivariate Data Exploration","title":"Real Time Data exploration"},{"location":"Dataexploration/#univariate-exploration","text":"Use univariate function to get the summarized univariate statistics for the data. Only argument needed for this function is the BET table for generating the summarized results. It returns a dataframe with all the univariate stats. #Importing artml explore module for calculating univariate from artml.explore import stats stats.univariate(BET) Created univarate statistics table looks like the one below. As the BET gets updated with new data, table also updates in real time to display the stats Stats feature 1 feature 2 feature 3 feature 4 feature 5 Count ---------- --------- --------- --------- --------- Mean ---------- --------- --------- --------- --------- Variance ---------- --------- --------- --------- --------- Standard_deviation ---------- --------- --------- --------- --------- coeff_of_variation ---------- --------- --------- --------- --------- skewness ---------- --------- --------- --------- --------- Kurtosis ---------- --------- --------- --------- ---------","title":"Univariate exploration"},{"location":"Dataexploration/#bivariate-exploration","text":"For getting bivariate stats for the data use covariance or correlation functions. These functions explores the concept of relationship between two attributes, whether there is an association and the strength of this association. ## Import artml explore module for calculating bivariate from artml.explore import stats stats.covariance(BET) stats.correlation(BET) Also, for comparing whether there are differences between two attributes and the significance of these differences, use Ztest or Ttest functions. stats.Ztest(BET, 'feature1name','feature2name') stats.Ttest(BET, 'feature1name','feature2name') Similarly, we can perform Ftest, ANOVA & Chi2 test using the syntaxes in the artml library.","title":"Bivariate exploration"},{"location":"artml/","text":"About artml Adaptive Real Time Machine Learning (artml) is a python library for building real time learning models. Many of the existing complex real time machine learning methods only rely on Incremental learning techniques limiting the true potential of Real time learning. Real time implies updating the models by only using the new data without pooling the old data again. This flexibility helps to update models in real time and also to build models using huge amounts of data. artml method has the flexibility to enhance the real time learning by giving all kind of flexibilities as mentioned below. Incremental learning - Updating the model with new data in real time Decremental learning - Updating the model by excluding unnecessary data in real time Real time attribute addition - Adding new features to the model in real time Real time attribute deletion - Deleting features from model in real time Distribute processing - Power to build models using distributed data Parallel processing - carrying out parallel processing using GPU's For further information and use cases visit artml blog . What is artml? artml is an open source python library for building real time learning models. Although most of the functions look similar to sklearn, for applying artml specific syntaxes and procedures should be followed. This work is Python adoption for Prof. Saed Sayad (University of Toronto) research on Real time Machine Learning. What can artml do for you? artml lets you build real time learning linear models and perform real time data exploration. We also have the flexibility for real time feature selection and for parallel and distributed processing. Installation Easily install artml from the GitHub source: First, clone artml using git: git clone https://github.com/AdaptiveMachineLearning/artml.git Then, import artml library into your python notebooks or files","title":"Home"},{"location":"artml/#about-artml","text":"Adaptive Real Time Machine Learning (artml) is a python library for building real time learning models. Many of the existing complex real time machine learning methods only rely on Incremental learning techniques limiting the true potential of Real time learning. Real time implies updating the models by only using the new data without pooling the old data again. This flexibility helps to update models in real time and also to build models using huge amounts of data. artml method has the flexibility to enhance the real time learning by giving all kind of flexibilities as mentioned below. Incremental learning - Updating the model with new data in real time Decremental learning - Updating the model by excluding unnecessary data in real time Real time attribute addition - Adding new features to the model in real time Real time attribute deletion - Deleting features from model in real time Distribute processing - Power to build models using distributed data Parallel processing - carrying out parallel processing using GPU's For further information and use cases visit artml blog .","title":"About artml"},{"location":"artml/#what-is-artml","text":"artml is an open source python library for building real time learning models. Although most of the functions look similar to sklearn, for applying artml specific syntaxes and procedures should be followed. This work is Python adoption for Prof. Saed Sayad (University of Toronto) research on Real time Machine Learning.","title":"What is artml?"},{"location":"artml/#what-can-artml-do-for-you","text":"artml lets you build real time learning linear models and perform real time data exploration. We also have the flexibility for real time feature selection and for parallel and distributed processing.","title":"What can artml do for you?"},{"location":"artml/#installation","text":"Easily install artml from the GitHub source: First, clone artml using git: git clone https://github.com/AdaptiveMachineLearning/artml.git Then, import artml library into your python notebooks or files","title":"Installation"},{"location":"bet/","text":"Basic Element table Creating Basic element table For using artml, a basic element table is created first which stores key information for each feature in summarized basic elements. This BET is key for all the successive steps. After generating BET, this table can be used for Data exploration & for Modeling. All the basic elements can be update in real time (incrementally or decrementally), using learn or forget functions. As, BET is updated with the new Data, we can update the model in real time. create_bet artml library has functions for building and updating the BET. Use these functions, for the streaming data to update the BET. Use create_bet function to build the BET. The only field you need to input is Dataframe or Data to build the BET. Output created is a Table in a Pandas dataframe format. #creating the basic elements table for the dataset. from artml import bet BET = bet.create_bet(DataToCreateBet) BET need to be created only once at the begininng, later on to make any further changes use learn or forget functions. Update BET learn The artml learn updates the basic elements table with any new incoming data. arguments needed for this function are BET (variable assigned for the created BET) and new dataframe. It returns the new updated BET as a dataframe. BET_New = bet.learn(BET, NewData) forget Similarly like learn function to update BET with the new data, if we want to remove the effect of some data from the BET we can use forget function. arguments needed for this function are BET (variable assigned for the created BET) and the data that needs to be deleted (Input as a dataframe). It returns the new BET as a dataframe. BET_updated = bet.forget(BET, Data) learnbyindex learnbyindex function is used to update BET at atomic level, we can update any of the feature with the new values. This function takes Basic Element Table and feature_names & values as arguments to update the given list of feature column & rows in the BET by corresponding values. BET_updated = bet.learnbyindex(Basic_Element_Table, 'feature_1','feature_2', 1, 2 ) #Above function updates feature_1, feature_2 in the BET by values 1 and 2 respectively forgetbyindex forgetbyindex function deletes the effect of given input values for corresponding given features. This function takes Basic Element Table and feature name & values as arguments to update the given list of features in the BET by corresponding values (deleting effect of those values from BET). BET_updated = bet.forgetbyindex(Basic_Element_Table, 'feature_1','feature_2', 1, 2 ) #Above function reduces feature_1, feature_2 in the BET by values 1 and 2 respectively","title":"Building Basic Element Table"},{"location":"bet/#basic-element-table","text":"","title":"Basic Element table"},{"location":"bet/#creating-basic-element-table","text":"For using artml, a basic element table is created first which stores key information for each feature in summarized basic elements. This BET is key for all the successive steps. After generating BET, this table can be used for Data exploration & for Modeling. All the basic elements can be update in real time (incrementally or decrementally), using learn or forget functions. As, BET is updated with the new Data, we can update the model in real time. create_bet artml library has functions for building and updating the BET. Use these functions, for the streaming data to update the BET. Use create_bet function to build the BET. The only field you need to input is Dataframe or Data to build the BET. Output created is a Table in a Pandas dataframe format. #creating the basic elements table for the dataset. from artml import bet BET = bet.create_bet(DataToCreateBet) BET need to be created only once at the begininng, later on to make any further changes use learn or forget functions.","title":"Creating Basic element table"},{"location":"bet/#update-bet","text":"learn The artml learn updates the basic elements table with any new incoming data. arguments needed for this function are BET (variable assigned for the created BET) and new dataframe. It returns the new updated BET as a dataframe. BET_New = bet.learn(BET, NewData) forget Similarly like learn function to update BET with the new data, if we want to remove the effect of some data from the BET we can use forget function. arguments needed for this function are BET (variable assigned for the created BET) and the data that needs to be deleted (Input as a dataframe). It returns the new BET as a dataframe. BET_updated = bet.forget(BET, Data) learnbyindex learnbyindex function is used to update BET at atomic level, we can update any of the feature with the new values. This function takes Basic Element Table and feature_names & values as arguments to update the given list of feature column & rows in the BET by corresponding values. BET_updated = bet.learnbyindex(Basic_Element_Table, 'feature_1','feature_2', 1, 2 ) #Above function updates feature_1, feature_2 in the BET by values 1 and 2 respectively forgetbyindex forgetbyindex function deletes the effect of given input values for corresponding given features. This function takes Basic Element Table and feature name & values as arguments to update the given list of features in the BET by corresponding values (deleting effect of those values from BET). BET_updated = bet.forgetbyindex(Basic_Element_Table, 'feature_1','feature_2', 1, 2 ) #Above function reduces feature_1, feature_2 in the BET by values 1 and 2 respectively","title":"Update BET"},{"location":"blog/","text":"What is ART-ML? In the recent years, Machine learning algorithms created a significant impact in all the sectors: Business and Marketing, from retail to finance, Education to Healthcare etc. Data is the key to success in all these applications. As the amount of data that is generated is increasing .... Real time data exploration In the Big Data world Exploring data is a prerequisite to analyzing data. Without proper exploration we could potentially use the wrong data and lead to non-optimal conclusions. Since the scope of datasets is very large, data exploration also brings important aspects of the data into focus for .... Adaptive Real time Algorithms In many of the real life cases ongoing training is needed in machine learning models. This continues training of model in real time helps to give more useful Business insights and make better predictions. Adaptive Real time machine Learning (ART-ML) can update models in real .... ARTML API Explanation- Iris dataset ART-ML library with its simple architecture can update the models in real time using the continuous streams of Data. Updating the model in real time has huge potential in many of the real world scenarios can impact Businesses. Many of the existing complex real time machine learning ....","title":"Blog"},{"location":"blog/#what-is-art-ml","text":"In the recent years, Machine learning algorithms created a significant impact in all the sectors: Business and Marketing, from retail to finance, Education to Healthcare etc. Data is the key to success in all these applications. As the amount of data that is generated is increasing ....","title":"What is ART-ML?"},{"location":"blog/#real-time-data-exploration","text":"In the Big Data world Exploring data is a prerequisite to analyzing data. Without proper exploration we could potentially use the wrong data and lead to non-optimal conclusions. Since the scope of datasets is very large, data exploration also brings important aspects of the data into focus for ....","title":"Real time data exploration"},{"location":"blog/#adaptive-real-time-algorithms","text":"In many of the real life cases ongoing training is needed in machine learning models. This continues training of model in real time helps to give more useful Business insights and make better predictions. Adaptive Real time machine Learning (ART-ML) can update models in real ....","title":"Adaptive Real time Algorithms"},{"location":"blog/#artml-api-explanation-iris-dataset","text":"ART-ML library with its simple architecture can update the models in real time using the continuous streams of Data. Updating the model in real time has huge potential in many of the real world scenarios can impact Businesses. Many of the existing complex real time machine learning ....","title":"ARTML API Explanation- Iris dataset"},{"location":"contributing/","text":"Contributing We are developing a community of artml contributors. This page is mostly about how to contribute code to the artml libraries, but there are many other ways you can contribute! Read about them here. Code of conduct artml to the Contributor Covenant Code of Conduct. By participating, you are expected to uphold this code. Creating Pull Requests To suggest changes, you need to create a fork of the library you want to change, and then submit a pull request. GitHub has instructions on how to do that here. Typos and other Small Fixes If you\u2019ve noticed a small bug or typo, please mention this in an issue, or if you feel comfortable doing so, please create a Pull Request with your fix. New Features If you want to add a new feature to Rasa, please create an issue first. Please also search through existing issues in case the topic has already been discussed. We will not automatically merge in a new feature just because you developed it, so it is worth discussing with the maintainers before you start work to avoid disappointment. If we merge in a new feature, we are taking on a lot of future work to maintain it. There is a good discussion of these trade-offs in the Elastic developer constitution . Tests Any new feature or change in behaviour must have a test written for it. This is enforced by our code review process. There must also be documentation for every feature. When you create a pull request, GitHub will include a checklist of everything that\u2019s required. Python 2 and 3 Cross Compatibility artml Currently runs in Python 3, although other major projects are online for other versions Adding new examples Even if you don't contribute to the artml source code, if you have an application of artml that is concise and powerful, please consider adding it to our collection of examples. Existing examples are only general examples of artml use cases, try coming up with new ideas. Contact: Have any questions? Shoot me an email and I shall get back to you asap! Also, we are looking to expand the artml team, contact me if you are interested. Happy Learning! Details Sundeep Pothula Email : sundeep.pothula@mail.utoronto.ca","title":"Contributing"},{"location":"contributing/#contributing","text":"We are developing a community of artml contributors. This page is mostly about how to contribute code to the artml libraries, but there are many other ways you can contribute! Read about them here. Code of conduct artml to the Contributor Covenant Code of Conduct. By participating, you are expected to uphold this code. Creating Pull Requests To suggest changes, you need to create a fork of the library you want to change, and then submit a pull request. GitHub has instructions on how to do that here. Typos and other Small Fixes If you\u2019ve noticed a small bug or typo, please mention this in an issue, or if you feel comfortable doing so, please create a Pull Request with your fix. New Features If you want to add a new feature to Rasa, please create an issue first. Please also search through existing issues in case the topic has already been discussed. We will not automatically merge in a new feature just because you developed it, so it is worth discussing with the maintainers before you start work to avoid disappointment. If we merge in a new feature, we are taking on a lot of future work to maintain it. There is a good discussion of these trade-offs in the Elastic developer constitution . Tests Any new feature or change in behaviour must have a test written for it. This is enforced by our code review process. There must also be documentation for every feature. When you create a pull request, GitHub will include a checklist of everything that\u2019s required. Python 2 and 3 Cross Compatibility artml Currently runs in Python 3, although other major projects are online for other versions","title":"Contributing"},{"location":"contributing/#adding-new-examples","text":"Even if you don't contribute to the artml source code, if you have an application of artml that is concise and powerful, please consider adding it to our collection of examples. Existing examples are only general examples of artml use cases, try coming up with new ideas.","title":"Adding new examples"},{"location":"contributing/#contact","text":"Have any questions? Shoot me an email and I shall get back to you asap! Also, we are looking to expand the artml team, contact me if you are interested. Happy Learning! Details Sundeep Pothula Email : sundeep.pothula@mail.utoronto.ca","title":"Contact:"},{"location":"demo/","text":"Digit classification using artml library Handwritten Digit classification is one of the standard mutliclass classification tasks in Machine learning. Although this is not a core application for using real time learning, To understand the usage of library and the power of linear models for complicated classification tasks, we opted this for demonstrating the artml API. In this demo project, you will know: Sample Preprocessing techniques Building Basic Element table Real Time Univariate Data Exploration Building Real time Multiclass classification Models Updating the BET and Models with the new dataset Let\u2019s get started. For python code, check the link. First step, Load the digits dataset (8*8) from the sklearn datasets. from sklearn.datasets import load_digits digits = load_digits() digits.images.shape Preprocess the data for one hot encoding the target feature and dividing the data into testing & training sets. from sklearn.model_selection import train_test_split Xtrain, Xtest, ytrain, ytest = train_test_split(X, y, random_state=0) y1 = pd.DataFrame(ytrain) y2 = pd.get_dummies(y1[0]) y2.columns = [str('Target_') +str(x) for x in range(0,10)] Since, we use QDA and SVC for classification, we need to make sure that the train data is not a singular matrix. Hence avoid null features from the dataset. [In the data exploration tasks observe these features and remove them while building the models] Then import artml library by following the installation guidelines and build the Basic Element table. from artml import bet BET1 = bet.create_bet(train_data1) In the above case for explanation purpose, we divided the training data into two sets. First we will build models using only some part of the data. Later, we update the models just by using the new data. from artml.explore import stats stats.univariate(BET1) Then use the above BET table for building different classification models as shown below. from artml.models import naive_bayes gnb = naive_bayes.GaussianNB() gnb.fit(BET1, 'Target_0', 'Target_1','Target_2', 'Target_3', 'Target_4', 'Target_5', 'Target_6', 'Target_7','Target_8', 'Target_9') gnb.score(Xtest.as_matrix(), ytest) for the GaussianNB model, we got the accuracy of 84.88% But, lets try and check the other models. from artml.models import QDA qda = QDA.QuadraticDiscriminantAnalysis() qda.fit(BET1, 'Target_0', 'Target_1','Target_2', 'Target_3', 'Target_4', 'Target_5', 'Target_6', 'Target_7','Target_8', 'Target_9') qda.score(Xtest, ytest) Eventhough QDA & SVC are powerful linear classification models we got a very low accuracy_score while testing these models. This might be because of the small amount of the training data. As, Naive bayes also works at small training datasets we got good accuracies in that case. from artml.models import svm svc = svm.LinearSVC() svc.fit(BET2, 'Target_0', 'Target_1','Target_2', 'Target_3', 'Target_4', 'Target_5', 'Target_6', 'Target_7','Target_8', 'Target_9', c=0.00001) svc.score(Xtest, ytest) Now lets try improving the model accuracy by using more training data instead of building complex models. for updating the model in real time first update the BET with new data using the learn function. BET2 = bet.learn(BET1, train_data2) Again, run the same above models using the new BET (New BET captures the total lager amount of training data in it!) After running the same above models we can observe that Naive_Bayes model accuracy slightly decreased - 82%. But QDA and SVC model accuracies largely improved to 93% & 45%. Below is the confusion matrix for the QDA predictions. Hence we can clearly see that QDA is a powerful linear model even for multiclass classification given enough amount of data. So, we can use these kind of models in real scenarios where we get continous data and where models need to be updated in real time for generating real time insights. Use this simple yet powerful API for building the realtime models. If you have an application of artml that is concise and powerful, please consider adding it to our collection of examples. Happy Learning!","title":"Demo Project"},{"location":"demo/#digit-classification-using-artml-library","text":"Handwritten Digit classification is one of the standard mutliclass classification tasks in Machine learning. Although this is not a core application for using real time learning, To understand the usage of library and the power of linear models for complicated classification tasks, we opted this for demonstrating the artml API. In this demo project, you will know: Sample Preprocessing techniques Building Basic Element table Real Time Univariate Data Exploration Building Real time Multiclass classification Models Updating the BET and Models with the new dataset Let\u2019s get started. For python code, check the link. First step, Load the digits dataset (8*8) from the sklearn datasets. from sklearn.datasets import load_digits digits = load_digits() digits.images.shape Preprocess the data for one hot encoding the target feature and dividing the data into testing & training sets. from sklearn.model_selection import train_test_split Xtrain, Xtest, ytrain, ytest = train_test_split(X, y, random_state=0) y1 = pd.DataFrame(ytrain) y2 = pd.get_dummies(y1[0]) y2.columns = [str('Target_') +str(x) for x in range(0,10)] Since, we use QDA and SVC for classification, we need to make sure that the train data is not a singular matrix. Hence avoid null features from the dataset. [In the data exploration tasks observe these features and remove them while building the models] Then import artml library by following the installation guidelines and build the Basic Element table. from artml import bet BET1 = bet.create_bet(train_data1) In the above case for explanation purpose, we divided the training data into two sets. First we will build models using only some part of the data. Later, we update the models just by using the new data. from artml.explore import stats stats.univariate(BET1) Then use the above BET table for building different classification models as shown below. from artml.models import naive_bayes gnb = naive_bayes.GaussianNB() gnb.fit(BET1, 'Target_0', 'Target_1','Target_2', 'Target_3', 'Target_4', 'Target_5', 'Target_6', 'Target_7','Target_8', 'Target_9') gnb.score(Xtest.as_matrix(), ytest) for the GaussianNB model, we got the accuracy of 84.88% But, lets try and check the other models. from artml.models import QDA qda = QDA.QuadraticDiscriminantAnalysis() qda.fit(BET1, 'Target_0', 'Target_1','Target_2', 'Target_3', 'Target_4', 'Target_5', 'Target_6', 'Target_7','Target_8', 'Target_9') qda.score(Xtest, ytest) Eventhough QDA & SVC are powerful linear classification models we got a very low accuracy_score while testing these models. This might be because of the small amount of the training data. As, Naive bayes also works at small training datasets we got good accuracies in that case. from artml.models import svm svc = svm.LinearSVC() svc.fit(BET2, 'Target_0', 'Target_1','Target_2', 'Target_3', 'Target_4', 'Target_5', 'Target_6', 'Target_7','Target_8', 'Target_9', c=0.00001) svc.score(Xtest, ytest) Now lets try improving the model accuracy by using more training data instead of building complex models. for updating the model in real time first update the BET with new data using the learn function. BET2 = bet.learn(BET1, train_data2) Again, run the same above models using the new BET (New BET captures the total lager amount of training data in it!) After running the same above models we can observe that Naive_Bayes model accuracy slightly decreased - 82%. But QDA and SVC model accuracies largely improved to 93% & 45%. Below is the confusion matrix for the QDA predictions. Hence we can clearly see that QDA is a powerful linear model even for multiclass classification given enough amount of data. So, we can use these kind of models in real scenarios where we get continous data and where models need to be updated in real time for generating real time insights. Use this simple yet powerful API for building the realtime models. If you have an application of artml that is concise and powerful, please consider adding it to our collection of examples. Happy Learning!","title":"Digit classification using artml library"},{"location":"faq/","text":"Building Real time Learning models Where can I learn about Adaptive real time Machine Learning? artml has a research paper with detailed descriptions on all models and techniques How should we preprocess the data before creating Basic Element table? Convert all categorical data to numerical by one hot encoding Even for bipartite data (Churn or NotChurn) two separate features should be created Numerical features can be binned if needed to create extra features Feature engineering plays a crucial role for better predictions, hence non linearity can be introduced by creating new features For simpler cases, avoid missing values. But if needed complex techniques can be adopted based on domain knowledge to tackle missing data How can we use complex models like decision trees for real time learning? Currently, artml only supports linear models. But it is learned that in most of the cases more data usually beats complex algorithms. Hence we can use more data and real time feature selection techniques for making better predictions using artml. Also, create more features that introduces non linearity to build powerful models. What is the difference between traditional Incremental/Online learning methods and artml? All other existing methods only offer Incremental learning. Given any new data, we can use Incremental learning approach to update the linear model. But we cannot remove the effect of some old data or we cannot add or delete features in a model using current methods. artml on the other hand offers all these flexibilities (Incremental learning/ Decremental learning/ Add or delete features/Parallel & distributed processing). for further detailed info about artml, please visit artml blog . How can we deploy artml models in a better way? Deploying artml algorithms is similar like sklearn models. Further deployed techniques including parallel & distributed processing techniques will be discussed in the later versions of artml. How can I get in touch? If you have a question about how to use artml, Please refer to addtional resources for further help. For bug reports and feature requests, please go to GitHub. For everything else please email sundeeppothula@gmail.com.","title":"FAQ"},{"location":"faq/#building-real-time-learning-models","text":"Where can I learn about Adaptive real time Machine Learning? artml has a research paper with detailed descriptions on all models and techniques How should we preprocess the data before creating Basic Element table? Convert all categorical data to numerical by one hot encoding Even for bipartite data (Churn or NotChurn) two separate features should be created Numerical features can be binned if needed to create extra features Feature engineering plays a crucial role for better predictions, hence non linearity can be introduced by creating new features For simpler cases, avoid missing values. But if needed complex techniques can be adopted based on domain knowledge to tackle missing data How can we use complex models like decision trees for real time learning? Currently, artml only supports linear models. But it is learned that in most of the cases more data usually beats complex algorithms. Hence we can use more data and real time feature selection techniques for making better predictions using artml. Also, create more features that introduces non linearity to build powerful models. What is the difference between traditional Incremental/Online learning methods and artml? All other existing methods only offer Incremental learning. Given any new data, we can use Incremental learning approach to update the linear model. But we cannot remove the effect of some old data or we cannot add or delete features in a model using current methods. artml on the other hand offers all these flexibilities (Incremental learning/ Decremental learning/ Add or delete features/Parallel & distributed processing). for further detailed info about artml, please visit artml blog . How can we deploy artml models in a better way? Deploying artml algorithms is similar like sklearn models. Further deployed techniques including parallel & distributed processing techniques will be discussed in the later versions of artml. How can I get in touch? If you have a question about how to use artml, Please refer to addtional resources for further help. For bug reports and feature requests, please go to GitHub. For everything else please email sundeeppothula@gmail.com.","title":"Building Real time Learning models"},{"location":"license/","text":"license To be updated...","title":"License"},{"location":"license/#license","text":"To be updated...","title":"license"},{"location":"models/","text":"ARTML Models ART-ML technique can be applied for all the linear regression and classification algorithms like MLR, Na\u00efve Bayesian, SVM, LDA, PCA etc. This section details how to use artml library for building different realtime regression & classification models. Classification models Naive Bayesian The Na\u00efve Bayesian classifier is based on Bayes\u2019 theorem with independence assumptions between attributes. In the real time version of Bayesian classifiers, we calculate the likelihood and the prior probabilities from the Basic Elements Table (BET) which can be updated in real time. We have Gaussian & Multinomial Regression models in artml library. For the numerical attributes likelihood can be calculated from the normal distribution equation and hence Guassian method can be used. for categorical data go for multinomial model. from artml.naive_bayes import GaussianNB gnb = GaussianNB() gnb.fit(BET, 'Target1','Target2') gnb.predict(Testing_data) gnb.score(TestingData, y_test) After importing GaussianNB , for fitting the classifier input Bascic Element table (BET) & target names. Even if it a binary classification task, two target names 'class' & 'notclass' should be given. For predicting give testing dataframe as the input. from artml.naive_bayes import MultinomialNB mnb = MultinomialNB() mnb.fit(BET, 'Target1','Target2') mnb.predict(Testing_data) mnb.score(TestingData, y_test) Using MultinomialNB is similar to GaussianNB. Follow similar syntax styles for categorical data also. Makesure to onehot encode all the categorical datavalues while building BET. Linear Discriminant Analysis LDA is based upon the concept of searching for a linear combination of attributes that best separates two classes (0 and 1) of a binary attribute. (LDA is only for binary classification) from artml.models import lda lda = lda.LinearDiscriminantAnalysis() lda.fit(BET, 'Target_name') lda.predict(TestingData) for fitting the 'lda' classifier, Basic Element table (BET) and Targetname are the only arguments required. Unlike Naivebayes, we can give only one target name (instead of churn and notchurn give only churn variable) in the input. For predicting give testing dataframe as the input. For multiclass classification use QDA instead of LDA. Quadratic Discriminant Analysis QDA is a general discriminant function with quadratic decision boundaries which can be used to classify datasets with two or more classes. from artml.models import lda QDA = QDA.QuadraticDiscriminantAnalysis() QDA.fit(BET, 'Target_name') QDA.predict(TestingData) arguments for fitting the classifier and making the predictions are similar to lda classification. Note: Since LDA & QDA involves inversion of the covariance matrices, makesure that it is not a singular matrix. (Avoid null features & multicollinearity) Support Vector classifier Support Vector Machine (SVM) performs classification by finding the hyperplane that maximizes the margin between the two classes. (SVC can be used for binary or multiclass classification) from artml.models import svm svc = svm.LinearSVC() svc.fit(BET, 'Target_name1', 'Target_name1' , c= 0.0001) svc.predict(TestingData) svc.score(TestingData, y_test) After importing LinearSVC , for fitting the classifier input Bascic Element table (BET) & target names. Even if it a binary classification task, two target names 'class' & 'notclass' should be given like we did in GaussianNB. Apart form BET and target names, value of c should be given as input. c is the tuning parameter and it should be adjusted to improve the classifier performance. For predicting give testing dataframe as the input. Note: Vary c value in the tenth powers to find the optimum value. [1,10,100,1000,0.1,0.001,...] Regression Models Multiple Linear regression Multiple Linear Regression (MLR) is a method used to model the linear relationship between a target (dependent variable) and one or more attributes (independent variables). Using MLR in artml is very similar to sklearn regression models. from artml.models import MLR lr = MLR.LinearRegression() lr.fit(BET, 'Target') lr.predict(TestingData) Arguments to fit the MLR model are only BET & target name. Use artml.metrics to find the R2 and other regression metrics. Note: Avoid Multicollinearity in the features. Multicollinearity leads to highly unreliable regression coefficient estimates and large errors in the test data. Use regression feature selection techniques for choosing the best features for MLR RidgeMLR artml also has the flexibility for using the regularized Linear regression model. Since Lasso regression doesnt have an analytical solution, we can use Ridge regression model and update it in real time using the Basic Element Table. from artml.models import MLR Rlr = MLR.RidgeRegression() Rlr.fit(BET, 'Target', c=0.1) Rlr.predict(TestingData) In the above arguments, c is the regularization parameter and it can be adjusted to reduce the overfitting by penalizing the larger weights in the model parameters. Support Vector regression LinearSVR is one of the powerful model for regression. Implementation of Support vector regression is similar to SVC. By building new features we can introduce nonlinearity into the LinearSVR model. from artml.models import svm svr = svm.LinearSVR() svr.fit(BET, 'Target', c=0.1) svr.predict(TestingData) Other than BET and targetname we have c tuning parameter in the SVR. default value of c is 0.1 and it can be adjusted to improve the model performance.","title":"Building Real Time Models"},{"location":"models/#artml-models","text":"ART-ML technique can be applied for all the linear regression and classification algorithms like MLR, Na\u00efve Bayesian, SVM, LDA, PCA etc. This section details how to use artml library for building different realtime regression & classification models.","title":"ARTML Models"},{"location":"models/#classification-models","text":"","title":"Classification models"},{"location":"models/#naive-bayesian","text":"The Na\u00efve Bayesian classifier is based on Bayes\u2019 theorem with independence assumptions between attributes. In the real time version of Bayesian classifiers, we calculate the likelihood and the prior probabilities from the Basic Elements Table (BET) which can be updated in real time. We have Gaussian & Multinomial Regression models in artml library. For the numerical attributes likelihood can be calculated from the normal distribution equation and hence Guassian method can be used. for categorical data go for multinomial model. from artml.naive_bayes import GaussianNB gnb = GaussianNB() gnb.fit(BET, 'Target1','Target2') gnb.predict(Testing_data) gnb.score(TestingData, y_test) After importing GaussianNB , for fitting the classifier input Bascic Element table (BET) & target names. Even if it a binary classification task, two target names 'class' & 'notclass' should be given. For predicting give testing dataframe as the input. from artml.naive_bayes import MultinomialNB mnb = MultinomialNB() mnb.fit(BET, 'Target1','Target2') mnb.predict(Testing_data) mnb.score(TestingData, y_test) Using MultinomialNB is similar to GaussianNB. Follow similar syntax styles for categorical data also. Makesure to onehot encode all the categorical datavalues while building BET.","title":"Naive Bayesian"},{"location":"models/#linear-discriminant-analysis","text":"LDA is based upon the concept of searching for a linear combination of attributes that best separates two classes (0 and 1) of a binary attribute. (LDA is only for binary classification) from artml.models import lda lda = lda.LinearDiscriminantAnalysis() lda.fit(BET, 'Target_name') lda.predict(TestingData) for fitting the 'lda' classifier, Basic Element table (BET) and Targetname are the only arguments required. Unlike Naivebayes, we can give only one target name (instead of churn and notchurn give only churn variable) in the input. For predicting give testing dataframe as the input. For multiclass classification use QDA instead of LDA.","title":"Linear Discriminant Analysis"},{"location":"models/#quadratic-discriminant-analysis","text":"QDA is a general discriminant function with quadratic decision boundaries which can be used to classify datasets with two or more classes. from artml.models import lda QDA = QDA.QuadraticDiscriminantAnalysis() QDA.fit(BET, 'Target_name') QDA.predict(TestingData) arguments for fitting the classifier and making the predictions are similar to lda classification. Note: Since LDA & QDA involves inversion of the covariance matrices, makesure that it is not a singular matrix. (Avoid null features & multicollinearity)","title":"Quadratic Discriminant Analysis"},{"location":"models/#support-vector-classifier","text":"Support Vector Machine (SVM) performs classification by finding the hyperplane that maximizes the margin between the two classes. (SVC can be used for binary or multiclass classification) from artml.models import svm svc = svm.LinearSVC() svc.fit(BET, 'Target_name1', 'Target_name1' , c= 0.0001) svc.predict(TestingData) svc.score(TestingData, y_test) After importing LinearSVC , for fitting the classifier input Bascic Element table (BET) & target names. Even if it a binary classification task, two target names 'class' & 'notclass' should be given like we did in GaussianNB. Apart form BET and target names, value of c should be given as input. c is the tuning parameter and it should be adjusted to improve the classifier performance. For predicting give testing dataframe as the input. Note: Vary c value in the tenth powers to find the optimum value. [1,10,100,1000,0.1,0.001,...]","title":"Support Vector classifier"},{"location":"models/#regression-models","text":"","title":"Regression Models"},{"location":"models/#multiple-linear-regression","text":"Multiple Linear Regression (MLR) is a method used to model the linear relationship between a target (dependent variable) and one or more attributes (independent variables). Using MLR in artml is very similar to sklearn regression models. from artml.models import MLR lr = MLR.LinearRegression() lr.fit(BET, 'Target') lr.predict(TestingData) Arguments to fit the MLR model are only BET & target name. Use artml.metrics to find the R2 and other regression metrics. Note: Avoid Multicollinearity in the features. Multicollinearity leads to highly unreliable regression coefficient estimates and large errors in the test data. Use regression feature selection techniques for choosing the best features for MLR","title":"Multiple Linear regression"},{"location":"models/#ridgemlr","text":"artml also has the flexibility for using the regularized Linear regression model. Since Lasso regression doesnt have an analytical solution, we can use Ridge regression model and update it in real time using the Basic Element Table. from artml.models import MLR Rlr = MLR.RidgeRegression() Rlr.fit(BET, 'Target', c=0.1) Rlr.predict(TestingData) In the above arguments, c is the regularization parameter and it can be adjusted to reduce the overfitting by penalizing the larger weights in the model parameters.","title":"RidgeMLR"},{"location":"models/#support-vector-regression","text":"LinearSVR is one of the powerful model for regression. Implementation of Support vector regression is similar to SVC. By building new features we can introduce nonlinearity into the LinearSVR model. from artml.models import svm svr = svm.LinearSVR() svr.fit(BET, 'Target', c=0.1) svr.predict(TestingData) Other than BET and targetname we have c tuning parameter in the SVR. default value of c is 0.1 and it can be adjusted to improve the model performance.","title":"Support Vector regression"},{"location":"quickstart/","text":"Quick start Adaptive Real Time Machine Learning (artml) is a python library for building real time learning models. In many of the real case scenarios past data is not the true representative for real time predictions, hence we need to update the models continously. artml library helps you to build these real time learning models. A quick introduction from artml import bet # import bet for creating basic element table. BET = bet.create_bet(dataframe) from artml.explore import stats stats.univariate(BET) from artml.models import lda lda = lda.LinearDiscriminantAnalysis() lda.fit(Traindata, 'target') y_pred = lda.predict(testdata) from artml.metrics import scores scores.accuracy(y_test, y_pred) For further information and use cases visit artml blog . Basic Data processing To begin using artml, first data should be preprocessed so as to build and update the basic element table. Basic preprocessing steps include - Imputing missing data One Hot encoding of categorical values Functions for above steps should be created so that streaming data can be preprocessed online. artml doesn't include functions for any of these and custom functions should created according to the project. Installation: clone artml using git git clone https://github.com/AdaptiveMachineLearning/artml.git Building Basic Element Table (BET) For using artml, basic element table is the key for all the successive steps. After generating BET, this table can be used for Data exploration & for Modeling. To use this in real time, BET can be updated in real time using the real time equation for BET. As, BET is updated with the new Data, we can update the model in real time. create_bet artml library has functions for building and updating the BET. Use these functions, for the streaming data to update the BET. Use create_bet function to build the BET. The only field you need to input is Dataframe or Data to build the BET. Output created is a Table in a Pandas dataframe format. #creating the basic elements table for the dataset. from artml import bet BET = bet.create_bet(DataToCreateBet) BET need to be created only once at the begininng, later on to make any further changes use learn or forget functions. learn After building the BET, to further update BET with the new data use learn function. arguments needed for this function are BET (variable assigned for the created BET) and new dataframe. It returns the new updated BET as a dataframe. BET_New = bet.learn(BET, NewData) forget Similarly like learn function to update BET with the new data, if we want to remove the effect of some data from the BET we can use forget function. arguments needed for this function are BET (variable assigned for the created BET) and the data that needs to be deleted (Input as a dataframe). It returns the new BET as a dataframe. BET_updated = bet.forget(BET, Data) Real Time Data exploration After generating BET, we can use it for data exploration to understand the summarized data. Real time Data Exploration can be categorized into two types: Real time Univariate Data Exploration Real time Bivariate Data Exploration Univariate exploration Use univariate function to get the summarized univariate statistics for the data. Only argument needed for this function is the BET table for generating the summarized results. It returns a dataframe with all the univariate stats. #Importing artml explore module for calculating univariate from artml.explore import stats stats.univariate(BET) bivariate exploration For getting bivariate stats for the data use covariance or correlation functions. Also, for comparing averages of groups whether they are statistically significant or not use Ztest or Ttest functions. #Importing artml explore module for calculating univariate from artml.explore import stats stats.covariance(BET) stats.correlation(BET) stats.Ztest(BET, 'feature1name','feature2name') Real Time Learning models ART-ML technique can be applied for all the linear regression and classification algorithms like MLR, Na\u00efve Bayesian, LDA, PCA etc., from artml.models import naive_bayes gnb = GaussianNB() gnb.fit(BET, 'Target1name','Target2name') y_pred = gnb.predict(TestingData) artml library is built in such a way to resemble syntaxes similar to sklearn functions. For detailed information about different models refer to Real Time Learning models section. Real Time Feature selection After building the real time learning models, artml also gives you the flexibility to configure models in real time by selecting the best features using feature_selection . For the artml feature selection use any of the below functions. #Importing feature_selection algorithm from artml library from artml.feature_selection import mahalanobis_features best_features = mahalanobis_features.mahalanobis_selection() features = best_features.forward_selection(BET,'Targetname', alpha=1.1) arguments for this function includes BET, 'targetname' and alpha value. For detailed information, Look into the further sections. Model Evaluation For general model evaluation like accuracy and scores, we can use general sklearn or the builtin functions in the artml (Either of them gives you similar results). Use scores function from artml as shown below #Import accuracy_score from artml for finding the accuracy of the model from artml.metrics import scores scores.accuracy(y_test, y_pred) Artml also includes extra features for real time model building and data exploration like, (some of them already exists in the current versions and ramaining will be updated later) Pipeline method for real time exploration to model Building Ttest and Ztest Functions Regularization for MLR (Ridge Regression) Backward and forward feature selection techniques","title":"Quick Start"},{"location":"quickstart/#quick-start","text":"Adaptive Real Time Machine Learning (artml) is a python library for building real time learning models. In many of the real case scenarios past data is not the true representative for real time predictions, hence we need to update the models continously. artml library helps you to build these real time learning models.","title":"Quick start"},{"location":"quickstart/#a-quick-introduction","text":"from artml import bet # import bet for creating basic element table. BET = bet.create_bet(dataframe) from artml.explore import stats stats.univariate(BET) from artml.models import lda lda = lda.LinearDiscriminantAnalysis() lda.fit(Traindata, 'target') y_pred = lda.predict(testdata) from artml.metrics import scores scores.accuracy(y_test, y_pred) For further information and use cases visit artml blog .","title":"A quick introduction"},{"location":"quickstart/#basic-data-processing","text":"To begin using artml, first data should be preprocessed so as to build and update the basic element table. Basic preprocessing steps include - Imputing missing data One Hot encoding of categorical values Functions for above steps should be created so that streaming data can be preprocessed online. artml doesn't include functions for any of these and custom functions should created according to the project. Installation: clone artml using git git clone https://github.com/AdaptiveMachineLearning/artml.git","title":"Basic Data processing"},{"location":"quickstart/#building-basic-element-table-bet","text":"For using artml, basic element table is the key for all the successive steps. After generating BET, this table can be used for Data exploration & for Modeling. To use this in real time, BET can be updated in real time using the real time equation for BET. As, BET is updated with the new Data, we can update the model in real time. create_bet artml library has functions for building and updating the BET. Use these functions, for the streaming data to update the BET. Use create_bet function to build the BET. The only field you need to input is Dataframe or Data to build the BET. Output created is a Table in a Pandas dataframe format. #creating the basic elements table for the dataset. from artml import bet BET = bet.create_bet(DataToCreateBet) BET need to be created only once at the begininng, later on to make any further changes use learn or forget functions. learn After building the BET, to further update BET with the new data use learn function. arguments needed for this function are BET (variable assigned for the created BET) and new dataframe. It returns the new updated BET as a dataframe. BET_New = bet.learn(BET, NewData) forget Similarly like learn function to update BET with the new data, if we want to remove the effect of some data from the BET we can use forget function. arguments needed for this function are BET (variable assigned for the created BET) and the data that needs to be deleted (Input as a dataframe). It returns the new BET as a dataframe. BET_updated = bet.forget(BET, Data)","title":"Building Basic Element Table (BET)"},{"location":"quickstart/#real-time-data-exploration","text":"After generating BET, we can use it for data exploration to understand the summarized data. Real time Data Exploration can be categorized into two types: Real time Univariate Data Exploration Real time Bivariate Data Exploration","title":"Real Time Data exploration"},{"location":"quickstart/#univariate-exploration","text":"Use univariate function to get the summarized univariate statistics for the data. Only argument needed for this function is the BET table for generating the summarized results. It returns a dataframe with all the univariate stats. #Importing artml explore module for calculating univariate from artml.explore import stats stats.univariate(BET)","title":"Univariate exploration"},{"location":"quickstart/#bivariate-exploration","text":"For getting bivariate stats for the data use covariance or correlation functions. Also, for comparing averages of groups whether they are statistically significant or not use Ztest or Ttest functions. #Importing artml explore module for calculating univariate from artml.explore import stats stats.covariance(BET) stats.correlation(BET) stats.Ztest(BET, 'feature1name','feature2name')","title":"bivariate exploration"},{"location":"quickstart/#real-time-learning-models","text":"ART-ML technique can be applied for all the linear regression and classification algorithms like MLR, Na\u00efve Bayesian, LDA, PCA etc., from artml.models import naive_bayes gnb = GaussianNB() gnb.fit(BET, 'Target1name','Target2name') y_pred = gnb.predict(TestingData) artml library is built in such a way to resemble syntaxes similar to sklearn functions. For detailed information about different models refer to Real Time Learning models section.","title":"Real Time Learning models"},{"location":"quickstart/#real-time-feature-selection","text":"After building the real time learning models, artml also gives you the flexibility to configure models in real time by selecting the best features using feature_selection . For the artml feature selection use any of the below functions. #Importing feature_selection algorithm from artml library from artml.feature_selection import mahalanobis_features best_features = mahalanobis_features.mahalanobis_selection() features = best_features.forward_selection(BET,'Targetname', alpha=1.1) arguments for this function includes BET, 'targetname' and alpha value. For detailed information, Look into the further sections.","title":"Real Time Feature selection"},{"location":"quickstart/#model-evaluation","text":"For general model evaluation like accuracy and scores, we can use general sklearn or the builtin functions in the artml (Either of them gives you similar results). Use scores function from artml as shown below #Import accuracy_score from artml for finding the accuracy of the model from artml.metrics import scores scores.accuracy(y_test, y_pred) Artml also includes extra features for real time model building and data exploration like, (some of them already exists in the current versions and ramaining will be updated later) Pipeline method for real time exploration to model Building Ttest and Ztest Functions Regularization for MLR (Ridge Regression) Backward and forward feature selection techniques","title":"Model Evaluation"},{"location":"release/","text":"Version 0.10.0 (2018-12) Added support for Python 3.3 and 3.4. Support for creating bet and real time data exploration Support for Linear models - Naivebayes, LDA, MLR, SVM Added documentation for all the functions and major bug fixes","title":"Release Notes"},{"location":"release/#version-0100-2018-12","text":"Added support for Python 3.3 and 3.4. Support for creating bet and real time data exploration Support for Linear models - Naivebayes, LDA, MLR, SVM Added documentation for all the functions and major bug fixes","title":"Version 0.10.0 (2018-12)"}]}